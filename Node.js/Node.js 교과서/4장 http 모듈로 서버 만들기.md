- [4.1 요청과 응답 이해하기](#41-요청과-응답-이해하기)
- [4.2 REST와 라우팅 사용하기](#42-rest와-라우팅-사용하기)
- [4.3 쿠키와 세션 이해하기](#43-쿠키와-세션-이해하기)
- [4.4 http와 http2](#44-http와-http2)
- [4.5 cluster](#45-cluster)

# 4.1 요청과 응답 이해하기

서버는 클라이언트가 있기에 동작한다. 클라이언트에서 서버로 요청(request)을 보내고, 서버에서는 요청의 내용을 읽고 처리한 뒤 클라이언트에 응답(response)을 보낸다.

따라서 서버에는 응답을 받는 부분과 응답을 보내는 부분이 있어야 한다. 요청과 응답은 이벤트 방식이라고 생각하면 된다. 클라이언트로부터 요청이 왔을 때 어떤 작업을 수행할지 이벤트 리스너를 미리 등록해두어야 한다.

```js
const http = require('http');

http.createServer((req, res) => {
    //여기에 어떻게 응답할지 적습니다.
});
```
http 서버가 있어야 웹 브라우저의 요청을 처리할 수 있으므로 http 모듈을 사용했다. http 모듈에는 **createServer** 메서드가 있다. 인수로 요청에 대한 콜백 함수를 넣을 수 있으며, 요청이 들어올 때마다 매번 콜백 함수가 실행된다. 따라서 이 콜백 함수에 응답을 적으면 된다.

createServer의 콜백 부분을 보면 req(request), res(response) 매개변수가 있다. req 객체에는 요청에 관한 정보들을, res 객체는 응답에 관한 정보들을 담고 있다.

```js
const http = require('http');

http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Server!</p>');
})
    .listen(8080, () => { // 서버 연결
        console.log('8080번 포트에서 서버 대기 중입니다!');
    });
```

노드로 파일을 실행하고 웹 브라우저를 열어 http://localhost:8080 또는 http://127.0.0.1:8080 에 접속한다.

> **localhost와 포트란?**  
> localhost는 현재 컴퓨터의 내부 주소를 가리킨다. 외부에서는 접근할 수 없고 자신의 컴퓨터에서만 접근할 수 있으므로, 서버 개발 시 테스트용으로 많이 사용된다. localhost 대신 127.0.0.1을 주소로 사용해도 같다. 이러한 숫자 주소를 IP(Internet Protocol)이라고 부른다.  
> 
> 포트는 서버 내에서 프로세스를 구분하는 번호이다. 서버는 HTTP 요청을 대기하는 것 외에도 다양한 작업을 한다. 데이터베이스와도 통신해야 하고, FTP 요청을 처리하기도 한다. 따라서 서버는 프로세스에 포트를 다르게 할당하여 들어오는 요청을 구분한다. 유명한 포트 번호로는 21(FTP), 80(HTTP), 443(HTTPS), 3306(MYSQL)이 있다. 포트 번호는 IP주소 뒤에 콜론(:)과 함꼐 붙여서 사용한다.  
>  
> 현재 예제에서는 임의의 포트 번호 8080에 노드 서버(프로세스)를 연결했다. 따라서 http://localhost:8080 으로 접근해야 한다.
> 
> 그런데 http://gilbut.co.kr 같은 사이트들은 포트 번호를 따로 표시하지 않는다. 바로 **80번 포트를 사용하기 때문이며, 80번 포트를 사용하면 주소에서 포트를 생략**할 수 있기 때문이다. https의 경우에는 443번 포트를 생략할 수 있다. http://gilbut.co.kr:80 으로 요청해도 길벗 홈페이지에 접속 가능하다.
> 
> 예제에서 80번 포트를 사용하지 않는 이유는 충돌 방지 때문이다. 일반적으로 컴퓨터에서 80번 포트는 이미 다른 서비스가 사용하고 있을 확률이 크다. 보통 포트 하나에 서비스를 하나만 사용할 수 있으므로 다른 서비스가 사용하고 있는 포트를 사용하려고 하면 에러가 발생한다.

createServer 메서드 뒤에 listen 메서드를 붙이고 클라이언트에 공개할 포트 번호화 포트 연결 완료 후 실행될 콜백 함수를 입력한다. 이제 이 파일을 실행하면 서버는 8080 포트에서 요청이 오기를 기다린다.

* res.writeHead: 응답에 대한 정보를 기록하는 메서드. 첫 번째 인수로 성공적인 요청임을 알리는 200을, 두 번째 인수로 응답에 대한 정보를 보내는데 콘텐츠의 형식이 HTML임을 알리고 있다.또한 한글 표시를 위해 charset을 utf-8로 지정했다. 이 **정보가 기록되는 부분을 헤더(Header)**라고 부른다.

* res.write 메서드의 첫 번째 인수는 클라이언트로 보낼 데이터이다. 지금은 HTML 모양의 문자열을 보냈지만 버퍼를 보낼 수도 있다. **데이터가 기록되는 부분을 본문(Body)**이라고 부른다.

* res.end: 응답을 종료하는 메서드. 만약 인수가 있다면 그 데이터도 클라이언트로 보내고 응답을 종료한다. 브라우저는 응답 내용을 받아서 렌더링한다.

listen 메서드에 콜백 함수를 넣는 대신, 서버에 listening 이벤트 리스너를 붙여도 되며, 추가로 error 이벤트 리스너도 가능하다.

```js
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Server!</p>');
});
server.listen(8080);

server.on('listening', () => {
    console.log('8080번 포트에서 서버 대기 중입니다!');
});
server.on('error', (error) => {
    console.error(error);
});
```

한 번에 여러 서버를 실행할 수도 있다. createServer를 원하는 만큼 호출하면 된다.

```js
const http = require('http');

const server = http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Server!</p>');
})
    .listen(8080, () => { // 서버 연결
        console.log('8080번 포트에서 서버 대기 중입니다!');
    });

http.createServer((req, res) => {
    res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
    res.write('<h1>Hello Node!</h1>');
    res.end('<p>Hello Server!</p>');
})
    .listen(8081, () => { // 서버 연결
        console.log('8081번 포트에서 서버 대기 중입니다!');
    })
```

각각 localhost:8080과 localhost:8081 주소로 서버에 접속할 수 있다. 이때 포트 번호가 달라야 한다. 포트 번호가 같으면 EADDINUSE 에러가 발생한다.

res.write와 res.end에 일일이 HTML을 적는 것은 비효율적이므로 미리 HTML 파일을 만들어두면 좋을 것 같다. 그 HTML 파일을 fs 모듈로 읽어서 전송할 수 있다.

```js
const http = require('http');
const fs = require('fs').promises;

http.createServer(async (req, res) => {
    try {
        const data = await fs.readFile('./server2.html');
        res.writeHead(200, { 'Content-Type': 'text/html; charset=utf-8' });
        res.end(data);
    } catch (err) {
        console.error(err);
        res.writeHead(500, { 'Content-Type': 'text/plain; charset=utf-8' });
        res.end(err.message);
    }
})
    .listen(8081, () => {
        console.log('8081번 포트에서 서버 대기 중입니다!');
    });
```

요청이 들어오면 먼저 fs 모듈로 HTML 파일을 읽는다. data 변수에 저장된 버퍼를 그대로 클라이언트에게 보내면 된다. 이전 예제에서는 문자열을 보냈지만, 저렇게 버퍼를 보낼 수도 있다.

> **HTTP 상태 코드**  
> 
> * 2XX: 성공을 알리는 상태 코드. 대표적으로 200(성공), 201(작성됨)이 많이 사용된다.
> * 3XX: 리다이렉션(다른 페이지로 이동)을 알리는 상태 코드. 어떤 주소를 입력했는데 다른 주소의 페이지로 넘어갈 때 이 코드가 사용됨. 대표적으로 301(영구 이동), 302(임시 이동)가 있다. 304(수정되지 않음)는 요청의 응답으로 캐시를 사용했다는 의미이다.
> * 4XX: 요청 오류를 나타낸다. 요청 자체에 오류가 있을 때 표시된다. 대표적으로 400(잘못된 요청), 401(권한 없음), 403(금지됨), 404(찾을 수 없음)가 있다.
> * 5XX: 서버 오류를 나타낸다. 요청은 제대로 왔지만 서버에 오류가 생겼을 때 발생한다. 이 오류가 뜨지 않게 주의해서 프로그래밍 해야 한다. 500(내부 서버 오류), 502(불량 게이트웨이), 503(서비스를 사용할 수 없음)이 자주 사용된다.

> **무조건 응답을 보내야 한다.**  
> 
> 요청 처리 과정 중에 에러가 발생했다고 해서 응답을 보내지 않으면 안 된다. 요청이 성공했든 실패했든 클라이언트로 보내서 요청이 마무리되었음을 알려야 한다. 응답을 보내지 않는다면, 클라이언트는 서버로부터 응답이 오길 기다리다가 일정 시간 후 Timeout(시간 초과) 처리한다.

# 4.2 REST와 라우팅 사용하기

서버에 요청을 보낼 때는 주소를 통해 요청의 내용을 표현한다. 주소가 /index.html이면 서버의 index.html을 보내달라는 뜻이고, /about.html이면 about.html을 보내달라는 뜻이다.

css나 js 또는 이미지 같은 파일을 요청할 수도 있고 특정 동작을 행하는 것을 요청할 수도 있다. 요청의 내용이 주소를 통해 표현되므로 서버가 이해하기 쉬운 주소를 사용하는 것이 좋다. 여기서 REST가 등장한다.

REST(REpresent State Transfer)는 서버의 자원을 정의하고 자원에 대한 주소를 지정하는 방법을 가리킨다. 일종의 약속이라고 봐도 무방하다. 서버가 행할 수 있는 것들을 통틀어서 자원을 의미한다.

주소는 의미를 명확히 전달하기 위해 명사로 구성된다. /user이면 사용자 정보에 관련된 자원을 요청하는 것이고, /post라면 게시글에 관련된 자원을 요청하는 것이라고 추측할 수 있다.

단순히 명사만 있으면 무슨 동작을 행하라는 것인지 알기 어려우므로 REST에서는 주소 외에도 **HTTP 요청 메서드**라는 것을 사용한다.

* GET: 서버 자원을 가져오고자 할 때 사용. 요청의 본문에 데이터를 넣지 않는다. 데이터를 서버로 보내야 한다면 쿼리스트링을 사용한다.

* POST: 서버에 자원을 새로 등록하고자 할 때 사용한다. 요청의 본문에 새로 등록할 데이터를 넣어 보낸다.

* PUT: 서버의 자원을 요청에 들어 있는 자원으로 치환하고자 할 때 사용한다. 요청의 본문에 치환할 데이터를 넣어 보낸다.

* PATCH: 서버의 자원을 일부만 수정하고자 할 때 사용한다. 요청의 본문에 일부 수정할 데이터를 넣어 보낸다.

* DELETE: 서버의 자원을 삭제하고자 할 때 사용한다. 요청의 본문에 데이터를 넣지 않는다.

* OPTIONS: 요청을 하기 전에 통신 옵션을 설명하기 위해 사용

주소 하나가 요청 메서드를 여러 개 가질 수 있다. GET 메서드의 /user 주소로 요청을 보내면 사용자 정보를 가져오는 요청, POST 메서드의 /user 주소로 요청을 보내면 새로운 새용자를 등록하려 한다는 것을 알 수 있다.

이렇게 주소와 메서드만 보고 요청의 내용을 알아볼 수 있다는 것이 장점이다. 또한, GET 메서드 같은 경우에는 브라우저에 캐싱(기억)할 수도 있으므로 같은 주소로 GET 요청을 할 때 서버에서 가져오는 것이 아니라 캐시에서 가져올 수도 있다.

HTTP 통신을 사용하면 클라이언트가 누구든 상관없이 같은 방식으로 서버와 소통할 수 있다. iOS, 안드로이드, 웹, 다른 서버가 모두 같은 주소로 요청을 보낼 수 있다. 즉, 서버와 클라이언트가 분리되어 있다는 뜻이다. 이렇게 서버와 클라이언트를 분리하면 **추후에 서버를 확장할 때 클라이언트에 구애되지 않아 좋다.**

예제 코드를 보면 req.method로 HTTP 요청 메서드를 구분하고 있다. 메서드가 GET이면 다시 req.url로 요청 주소를 구분한다. 만약 존재하지 않는 파일을 요청했거나 GET 메서드 요청이 아닌 경우 404 NOT FOUND 에러가 응답으로 전송 된다. 응답 과정 중에 예기치 못한 에러가 발생한 경우 500에러가 응답으로 전송된다.

> **res.end 앞에 return을 붙이는 이유**
> 
> 노드도 일반적인 자바스크립트 문법을 따르므로 return을 붙이지 않는 한 함수가 종료되지 않는다. return을 써서 명시적으로 함수를 종료하는 것이다.

예제에서 다른 HTTP 메서드를 추가하고, 데이터베이스 대용으로 users라는 객체를 선언하여 사용자 정보를 저장했다. POST /user 요청에서는 사용자를 새로 저장하고 있으며, PUT /users/아이디 용청에서는 해당 아이디의 사용자 데이터를 수정하고 있다. DELETE /user/아이디 요청에서는 해당 아이디의 사용자를 제거한다.

POST와 PUT 요청을 처리할 때 req.on('data')와 req.on('end')를 사용한다. 오청의 본문에 들어있는 데이터를 꺼내기 위한 작업이다. **req와 res도 내부적으로 스트림으로 되어 있으므로 요청/응답의 데이터가 스트림 형식으로 전달된다.

브라우저의 Network 탭에서 보면 REST 방식으로 주소를 만들었으므로 주소와 메서드를 통해 요청 내용을 유추할 수 있다.

* Name: 요청 주소
* Method: 요청 메서드
* Status: HTTP 응답 코드
* Protocol: 통신 프로토콜
* Type: 요청의 종류(xhr은 AJAX 요청)

> **헤더와 본문**
> 요청과 응답은 모두 **헤더**와 **본문**을 가지고 있다. **헤더**는 요청 또는 응답의 정보를 가지고 있는 곳이고, **본문**은 서버와 클라이언트 간에 주고받을 실제 데이터를 담아두는 공간이다.

주의할 점은 데이터가 메모리에 저장되므로 서버를 종료하면 데이터가 소실된다는 것이다. 데이터를 영구히 저장하기 위해서는 데이터 베이스를 사용해야 한다.

# 4.3 쿠키와 세션 이해하기

클라이언트에서 보내는 요청에는 누가 요청을 보내는지 모른다는 단점이 있다. 물론 요청을 보내는 IP 주소나 브라우저의 정보를 받아올 수는 있다. 하지만 여러 컴퓨터가 공통으로 IP 주소를 가지거나, 한 컴퓨터를 여러 사람이 사용할 수도 있다.

이때 사용하는 것이 로그인이며, 로그인을 구현하기 위해서는 **쿠키**와 **세션**에 대해 알고 있어야 한다. 로그인 한 이후에 새로고침을 해도 로그아웃 되지 않는 이유는 클라이언트가 서버에 누구인지 지속적으로 알려주고 있기 때문이다.

누구인지 기억하기 위해서 서버는 요청에 대한 응답을 할 때 쿠키라는 것을 같이 보낸다. **쿠키는 유효기간이 있으며 단순한 '키-값'의 쌍**이다. 서버로부터 쿠키가 오면 웹 브라우저는 쿠키를 저장해두었다가 다음에 **요청할 때마다 쿠키를 동봉**해서 보낸다. **서버는 요청에 들어있는 쿠키를 읽어서 사용자가 누구인지 파악**한다.

서버는 미리 클라이언트에 요청자를 추정할 만한 정보를 쿠키로 만들어 보내고, 그 다음부터는 클라이언트로부터 쿠키를 받아 요청자를 파악한다. 쿠키의 요청은 헤더(Cookie)에 담겨 전송된다. 브라우저는 응답의 헤더(Set-Cookie)에 따라 쿠키를 저장한다.

```js
const http = require('http');

http.createServer((req, res) => {
    console.log(req.url, req.headers.cookie);
    res.writeHead(200, { 'Set-Cookie': 'mycookie=test' });
    res.end('Hello Cookie');
})
    .listen(8083, () => {
        console.log('8083번 포트에서 서버 대기 중입니다!');
    });
```

쿠키는 name=seongtae;year=1998처럼 문자열 형식으로 존재한다. 쿠키 간에는 세미콜론(;)으로 구분된다.

createServer 메서드의 콜백에서는 req 객체에 담겨 있는 쿠키를 가져온다. 쿠키는 req.headers.cookie에 들어 있다. req.headers는 요청의 헤더를 의미한다.

응답의 헤더에 쿠키를 기록해야 하므로 res.writeHead 메서드를 사용한다. Set-Cookie는 브라우저한테 다음과 같은 값의 쿠키를 저장하라는 의미이다.

실행 결과 요청이 한 개이지만 두 개가 기록되어 있는데 /favicon.ico가 추가적으로 요청되어 { mycookie: 'test' }가 기록되어 있다. 파비콘(favicon)이란 웹사이트 탭에 보이는 이미지를 뜻하는데, 파비콘이 뭔지 HTML에서 유추할 수 없으면 서버에 파비콘 정보에 대한 요청을 보낸다. 따라서 favicon에 대한 요청이 보내진 것이다.

---

쿠키는 mycookie=test 같은 문자열이기 때문에 자바스크립트 객체 형식으로 바꾸는 함수를 사용해 객체로 전환한다.

주소가 /login으로 시작할 경우에 url과 querystring 모듈로 각각 주소와 주소에 딸려오는 query를 분석한다. 쿠키의 만료 시간도 5분으로 설정한다. 이제 302 응답 코드, 리다이렉트 주소와 함께 쿠키를 헤더에 넣는다. 브라우저는 이 응답 코드를 보고 페이지를 해당 주소로 리다이렉트한다. 헤더에는 한글을 설정할 수 없으므로 name변수를 encodeURIComponent 메서드로 인코딩한다. 또한 Set-Cookie의 값으로는 ASCII 코드만 들어가야 하므로 줄바꿈을 넣어서는 안된다.

그 외의 경우(/로 접속했을 때 등), 먼저 쿠키가 있는지 없는지를 확인한다. 쿠키가 없다면 로그인할 수 있는 페이지를 보낸다. 처음 방문한 경우에는 쿠키가 없으므로 cookie2.html이 전송되며 쿠키가 있다면 로그인한 상태로 간주하여 인사말을 보낸다.

* 쿠키명=쿠키값: 기본적인 쿠키의 값이다. mycookie=test와 같이 설정

* Expires=날짜: 만료 기한. 이 기간이 지나면 쿠키가 제거된다.

* Max-age=초: Expires와 비슷하지만 날짜 대신 초를 입력할 수 있다. Expires보다 우선한다.

* Domain=도메인명: 쿠키가 전송될 도메인을 특정할 수 있다.

* Path=URL: 쿠키가 전송될 URL을 특정할 수 있다. 기본값은 '/'이고 이 경우 모든 URL에서 쿠키를 전송할 수 있다.

* Secure: HTTPS일 경우에만 쿠키가 전송된다.

* HttpOnly: 설정 시 자바스크립트에서 쿠키에 접근할 수 없다. 쿠키 조작을 방지하기 위해 설정하는 것이 좋다.

그런데 민감한 개인 정보를 쿠키에 저장하는 것은 적절하지 않기 때문에 서버가 사용자 정보를 관리하도록 만들어보자.

서버에 사용자 정보를 저장하고 클라이언트와는 세션 아이디로만 소통한다. 세션 아이디는 꼭 쿠키를 사용해서 주고받지 않아도 된다. 하지만 많은 웹 사이트가 쿠키를 사용하는 이유는, 쿠키를 사용하는 방법이 가장 간단하기 때문이다. 세션을 위해 사용하는 쿠키를 **세션 쿠키**라고 부른다.

보통 쿠키를 메모리에 저장하지 않고 레디스(Redis)나 멤캐시드(Memcached)같은 데이터베이스에 넣어둔다.

> 서비스를 새로 만들 때마다 쿠키와 세션을 직접 구현할 수는 없다. 위의 방식 역시 세션 아이디 값이 공개되어 있어 보안 등의 문제도 있으니 조심할 것.

# 4.4 http와 http2

https 모듈은 웹 서버에 SSL 암호화를 추가한다. GET이나 POST 요청을 할 때 오가는 데이터를 암호화해서 중간에 다른 사람이 요청을 가로채더라도 내용을 확인할 수 없게 한다.

하지만 https는 아무나 사용할 수 없다. 암호화를 적용하는 만큼 그것을 인증해줄 수 있는 기관도 필요하다. 인증서는 인증 기관에서 구입해야 하며, Let's Encrypt 같은 기관에서 무료로 발급해주기도 한다.

createServer 메서드가 인수를 두 개 받는다. 두 번째 인수는 http모듈과 같이 서버 로직이고, 첫 번째 인수는 인증서에 관련된 옵션 객체이다. 인증서를 구입하면 pem이나 crt, 또는 key 확장자를 가진 파일들을 제공한다. 파일들을 fs.readFileSync 메서드로 읽어서 cert, key, ca 옵션에 알맞게 넣으면 된다. 실제 서버에서는 80 포트 대신 443 포트를 사용하면 된다.

노드의 http2 모듈은 SSL 암호화와 더불어 최신 HTTP 프로토콜인 http/2를 사용할 수 있게 한다. http/2는 요청 및 응답 방식이 기존 http/1.1보다 개선되어 훨씬 효율적으로 요청을 보낸다. http/2를 사용하면 웹의 속도도 많이 개선된다.

# 4.5 cluster

cluster 모듈은 기본적으로 싱글 프로세스로 동작하는 노드가 CPU 코어를 모두 사용할 수 있게 해주는 모듈이다. 포트를 공유하는 노드 프로세스를 여러 개 둘 수도 있으므로, 요청이 많이 들어왔을 때 병렬로 실행된 서버의 개수만큼 요청이 분산되게 할 수 있다. 즉, 서버에 무리가 덜 가게 할 수 있다.

코어를 하나 쓸 때에 비해 성능이 개선되지만, 메모리를 공유하지 못하는 등의 단점도 있다.

스레드가 아니라 프로세스라는 점이 worker_thread와 다른 점이며, 마스터 프로세스와 워커 프로세스가 있다. 마스터 프로세스는 CPU 개수만큼 워커 프로세스를 만들고 요청이 들어오면 워커 프로세스에 요청을 분배한다.

코드(code)는 process.exit의 인수로 넣어준 코드가 출력되고, 신호(signal)는 존재하는 경우 프로세스를 종료한 신호의 이름이 출력된다.

워커 프로세스가 존재하기에 CPU 코어 개수만큼 오류가 발생해도 서버가 정상 작동할 수 있다는 뜻이다. 종료된 워커를 다시 켜면 오류가 발생해도 계속 버틸 수 있다.

하지만 이렇게 오류를 처리하는 것보다 오류 자체의 원인을 찾아 해결하는 것이 중요하다. 그러나 **예기치 못한 에러로 서버가 종료되는 현상을 방지**할 수 있어 클러스터링을 적용해두는 것이 좋다.